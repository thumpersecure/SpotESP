# SpotESP
Spot ESP will leverage the ESP32-CYD hardware to provide a comprehensive defensive monitoring tool. Spot ESP aims to be a fresh, optimized solution tailored for the Cheap Yellow Display platform, turning it into a portable wireless threat detector.

🔥 Explanation of Features
	1.	Wi-Fi Deauth Detection
	•	Uses ESP32’s promiscuous mode to capture all packets.
	•	Filters management packets and checks for deauth attack frames (Subtype 12).
	•	When detected, updates the UI and logs the event to SD.
	2.	Bluetooth Scanner for Flipper Zero / Skimmers
	•	Uses NimBLE for lightweight BLE scanning.
	•	Detects known BLE skimmers (e.g., HC-05) and Flipper Zero devices.
	•	Alerts user with UI messages and logs threats.
	3.	Touchscreen UI Alerts
	•	Displays “Deauth Attack Detected” messages when attacks are seen.
	•	Changes screen background to red for immediate visibility.
	4.	SD Card Logging
	•	Logs attack events to an SD card (spotesp.log).
	•	Stores timestamps and signal strength.
	5.	Channel Hopping
	•	Cycles through Wi-Fi channels 1-11 every 500ms.
	•	Ensures detection across all networks.

⸻

🚀 Next Steps
	•	Improve UI Menus (Add logs viewer and settings)
	•	Enhance BLE detection (Whitelist common devices to reduce false alerts)
	•	Optimize Performance (Adjust Wi-Fi/BLE scan balance)
	•	Include More Threats (Pineapple detection, rogue APs)
	•	User Configuration Options (Enable/Disable detection types)

This is the first version of the Spot ESP firmware




Spot ESP Development Plan

Project Overview:
Spot ESP is a defensive firmware for the ESP32-2432S028 “Cheap Yellow Display” (CYD) board, focused solely on detecting wireless attacks and anomalies (with no offensive/jamming capabilities). It continuously monitors Wi-Fi and Bluetooth signals to alert the user of potential threats like deauthentication floods, rogue access points, malicious Bluetooth devices (e.g. skimmers), and suspicious gadgets (Wi-Fi Pineapples, Flipper Zero, etc.). This guide outlines a structured plan to implement Spot ESP, covering everything from required tools to detection algorithms, UI design, logging, performance, and challenges.

1. Development Environment, Libraries, and Tools
	•	ESP32 Framework: Use either the ESP-IDF (Espressif IoT Development Framework) or Arduino-ESP32 core for development. Arduino offers quicker prototyping and library support, while ESP-IDF provides fine-grained control and performance tuning. In either case, ensure the environment supports both Wi-Fi and Bluetooth functionality of the ESP32.
	•	Display & Touch Libraries: The CYD board uses a 2.8-inch 240×320 TFT (ILI9341 driver) with resistive touch (XPT2046 controller) . Install TFT_eSPI (optimized graphics library for ILI9341) and XPT2046_Touchscreen (for resistive touch input). These libraries simplify drawing to the LCD and reading touch coordinates.
	•	Wi-Fi Sniffing Utilities: Utilize the ESP32’s promiscuous mode APIs to capture 802.11 frames. In Arduino, include the esp_wifi.h from IDF or use libraries from projects like Marauder. For example, the ESP32 Marauder firmware uses Espressif’s Wi-Fi sniffer to detect deauth packets . We can reuse such logic for Spot ESP’s Wi-Fi monitoring.
	•	Bluetooth Libraries: For Bluetooth Low Energy (BLE) scanning, use the NimBLE library (a lightweight BLE stack) or the default Arduino BLE. NimBLE is preferred for its lower memory footprint and ability to scan continuously with minimal impact. If classic Bluetooth scanning is needed (e.g. to detect legacy BT skimmers), ensure the Bluedroid stack is enabled in menuconfig or use Arduino’s “BluetoothSerial” for device inquiry.
	•	SD Card & Filesystem: The board has a microSD slot , useful for log storage. Include SD (SPI mode) library to write logs or captured packet data. Alternatively, use SPIFFS/LittleFS in flash if SD is not used. Logging to SD was also a feature in Marauder (e.g. saving PCAP files) , so Spot ESP can follow a similar approach for record-keeping.
	•	Other Tools: A serial terminal (for debug logs), and optionally the PlatformIO IDE (which has good ESP32 and library support). If using ESP-IDF, the idf.py menuconfig can set Wi-Fi sniffer options and Bluetooth dual-mode. Install any required USB drivers to program the CYD via its microUSB port.

2. Hardware Initialization and Configuration

ESP32-2432S028 “Cheap Yellow Display” board (back view) with key components labeled: ESP32-WROOM module, touch TFT display (on front side), microSD slot, speaker, RGB LED, and IO pins.
Before implementing detection logic, initialize all hardware components:
	•	Board-Specific Setup: Configure the ESP32 pins according to the CYD’s wiring. The CYD integrates an ESP32-WROOM-32 module with the TFT, touch controller, SD slot, RGB LED, and a small speaker on board  . Use the board’s definitions if available, or manually map pins based on documentation (e.g., SPI pins for the display, CS/DC pins, touch IRQ/CS pins, SD CS pin, etc.). Set the SPI frequencies (e.g. 40MHz for display) as supported.
	•	Display Initialization: Initialize the TFT display with TFT_eSPI (ensure the library’s User_Setup matches the CYD pinout). Clear the screen and perhaps show a splash screen or logo. Calibrate the resistive touchscreen if needed (XPT2046 typically requires calibration data to map coordinate system).
	•	Wi-Fi Module Config: Start the Wi-Fi in sniffer/promiscuous mode without connecting to any AP. Use esp_wifi_set_promiscuous(true) and set a callback to receive packet data. Configure the sniffer to include management frames and control frames, since attack detection will focus on those. Optionally set channel filtering to rotate channels (e.g., hop 1–11 in US) to cover the spectrum. The ESP32 can’t sniff all channels simultaneously (single radio), so implement a channel-hopping timer (e.g., switch channel every 200ms) to sample all channels for threats. If the user connects Spot ESP to a specific Wi-Fi (for anomaly detection on that network), lock sniffing to that channel plus immediate neighbors for efficiency.
	•	Bluetooth Config: Initialize NimBLE or Bluedroid stack in observer mode. Set up BLE scanning parameters (scan interval and window) to continuously scan for advertising packets. Use passive scanning (non-connectable) so Spot ESP just listens for adverts without engaging devices. Also, if using classic BT inquiry (for skimmers), start periodic inquiries for discoverable devices. Ensure the Bluetooth is started in a mode that can run concurrently with Wi-Fi. (The ESP32 can run Wi-Fi and BLE simultaneously via time-slicing; test and tune the scan parameters to balance Wi-Fi sniffing with BLE scanning).
	•	RGB LED & Speaker: Initialize the on-board RGB LED (connected to GPIO4, 16, 17)  for status indication. Similarly, set up the small speaker (or buzzer) – this might be tied to a DAC or PWM-capable pin (refer to CYD schematics). We can use the speaker to beep on alerts or play a short tone for critical warnings. The LED can glow green when all is normal, and switch to red or blink when an attack is detected. These provide immediate feedback even if the user isn’t watching the screen.
	•	Input Controls: The primary input is the resistive touchscreen. Initialize touch reading and create a simple calibration (map raw touch X/Y to screen pixels). If the device has side buttons (e.g., BOOT/RST can be repurposed, or TX/RX ports for external buttons), configure GPIOs for those as menu navigation buttons as a backup to touch input. Having physical buttons (like one for Menu/Back and one for Select) can improve usability if touch calibration is off or if the user prefers tactile input (the Bruce firmware UI, for example, relies on bottom buttons for navigation ).
	•	Power Management: Since continuous scanning can be power-intensive, configure the ESP32’s power management as needed (if running on battery, perhaps use light sleep between scans). The CYD board draws ~115 mA normally ; we might reduce backlight brightness or clock frequency when idle to save power. Ensure the backlight control pin (if available) is set (some boards have a TFT LED pin or use a transistor for brightness control).
	•	Self-Test: On startup, Spot ESP should test all subsystems – display, touch, SD card (if present), Wi-Fi, BLE, LED, speaker – and report any issues on screen for troubleshooting (e.g., “SD card not found” or “Wi-Fi init failed”). This ensures the hardware is ready for the monitoring tasks ahead.

3. Attack Detection Algorithms and Methods

This is the core of Spot ESP: continuously monitoring various channels and protocols to identify signs of common attacks. The firmware will implement separate detection routines for each category of threat, raising alerts when suspicious patterns are observed. Below are the detection strategies for each specified attack type:

3.1 Wi-Fi Deauthentication Attack Detection
	•	Symptoms: Wi-Fi deauth attacks involve an attacker sending forged deauthentication frames to disconnect clients. These frames are 802.11 management packets (type 0, subtype 12) not normally seen in large numbers in a healthy network.
	•	Detection Method: Spot ESP will use the promiscuous sniffer to count deauth (and disassociation) frames in the air. If it sees an abnormally high number of deauth packets within a short time (e.g. >5–10 deauths per second, or a burst of dozens at once), it flags a potential attack . A dedicated parsing of the sniffer callback can filter frames with subtype == deauth or disassoc and increment a counter.
	•	Contextual Filtering: To minimize false alarms, the firmware might track known APs and clients. For example, a single deauth frame when a router reboots (disconnecting everyone) is benign, but dozens of repeated deauths (often targeting different clients or all clients) indicate a malicious deauth flood. If Spot ESP is connected to a network, it can specifically watch for deauth frames targeting its own STA MAC or its AP’s BSSID as a stronger sign of an attack on the user’s network.
	•	Alerting: On detection, Spot ESP logs the time, channel, and MAC addresses involved (attacker’s MAC if obtainable from frame source, and target). It also displays a “Deauth Attack Detected” warning in the UI with details (e.g. “Multiple deauth packets from MAC 84:CC:FA:… on ch6”), and triggers an audible beep or red LED flash. This feature is similar to Marauder’s “Deauth sniff” mode which specifically monitors for deauth frames , but Spot ESP will run it in the background continuously.

3.2 Bluetooth (BLE) Attack Detection
	•	Scope: Bluetooth attacks could include attempts to spam pairing requests, crash devices via BLE vulnerabilities, or overwhelm with advertisements. Recent hacks (like BLE spam attacks) send a flurry of bogus pairing notifications to phones (e.g. “Sour Apple” iOS crash via BLE, or SwiftPair spam on Windows  ). While Spot ESP cannot prevent these, it can detect their presence by monitoring the BLE traffic.
	•	BLE Scanning: The firmware will scan for unusual advertising patterns. For example, if one device is rapidly changing its BLE address and sending repeated connectable advertisements (a technique used in BLE spam attacks), Spot ESP can notice an extremely high rate of adverts. Normal BLE beacons (like iBeacons or fitness trackers) send at most a few per second. An attack might generate dozens per second or craft advertisement data indicative of known exploits (such as certain payload lengths or UUIDs targeting vulnerabilities).
	•	Identification: Implement logic to detect known attack signatures:
	•	Pairing Request Storm: Detect if the ESP32’s BLE stack receives back-to-back pairing or connection requests. Although Spot ESP will not be advertising itself, some attacks like unsolicited pairing requests might still be observable if the attacker brute-forces connect attempts on any BLE peripheral in range (however, this is harder to detect without being a target device). Alternatively, Spot ESP could periodically advertise a bait BLE name to catch if attackers try to pair with it, purely for detection logging.
	•	BLE Spam Advertisements: Monitor advertising channels for devices that broadcast with rapidly cycling IDs or with names that correspond to known spam attacks. For instance, tools like Flipper Zero can spam BLE advertisements named “AirTag” or random strings to annoy users. Spot ESP can flag if it sees an implausibly high diversity of advertised names or a single source sending >X ads/sec.
	•	BLE Jamming/DoS: If someone attempts a BLE jamming (like flooding the BLE channels), the symptom would be Spot ESP’s scanner being overwhelmed or seeing continuous maxed-out traffic. The firmware can measure the BLE scan buffer fill level or missed advertisement events as an indirect sign of interference.
	•	Alerting: Upon detecting a probable BLE attack, Spot ESP can display “BLE anomaly detected” with info such as the offending device’s address (if one source) or simply a general warning if it’s broad interference. In logs, include the BLE device address, advertised name/UUID, and count of packets. For example: “BLE spam from XX:YY:ZZ:12:34:56 (name: ‘BLESpam’): 200 adverts in 10s”.
	•	Note: Bluetooth LE detection by nature is more speculative than Wi-Fi (since we can’t easily capture all specifics of an ongoing pairing spam without being the target). However, monitoring advertisement traffic patterns provides a reasonable indication of BLE-based attacks.

3.3 Bluetooth Skimmer Detection
	•	Threat: Credit card skimmers (like those placed on gas pumps or ATMs) often use Bluetooth to transmit stolen card data. These are usually small hidden devices with Bluetooth modules so that the thief can later download the data wirelessly. Spot ESP will incorporate a skimmer detector similar to Marauder’s “Detect Card Skimmers” feature .
	•	Detection Method: Skimmers commonly use inexpensive Bluetooth modules (e.g., HC-05, HC-06, HM-10) or BLE boards, often left with default settings. They might have default device names (like “HC-05”), or specific serial service UUIDs. Spot ESP’s Bluetooth scanner will maintain a list of known suspicious Bluetooth identifiers:
	•	Classic BT device names like “HC-05”, “HC-06”, “BTModule”, or common skimmer names (some skimmers broadcast a fixed name or ID).
	•	BLE service UUIDs often used in skimmer firmware (if publicly known from law enforcement bulletins or projects like BSP60 skimmer).
	•	The firmware will flag any nearby Bluetooth device whose name or advertised data matches these signatures. For example, if a device named “HC-05” is detected and it’s not expected in the area, Spot ESP would treat it as a potential skimmer and alert the user. It can also look at the MAC address OUI – many skimmer boards use cheap modules with known manufacturer IDs (e.g., OUI belonging to Shenzhen electronics manufacturers).
	•	User Feedback: When a suspected skimmer is detected, the UI could highlight it in a list (e.g., under a “Skimmers” section) with an indicator. An on-screen message like “⚠️ Possible Card Skimmer detected: BT name ‘HC-05’” will inform the user. Log details including MAC, RSSI (signal strength, to gauge proximity), and time first seen. This helps the user physically search for the skimmer device. The detection should be refreshed – if the device is no longer seen, mark it accordingly.
	•	Note: To reduce false alarms, allow the user to approve/ignore certain devices (for instance, if a store legitimately has a Bluetooth device named HC-05, the user can whitelist it). Spot ESP’s goal is to reliably spot the unintended or hidden Bluetooth endpoints that could be skimmers, much like Marauder’s skimmer scanner which scans for “bluetooth enabled credit card skimmers” .

3.4 Nearby Wi-Fi Pineapple Detection
	•	Threat Device: The Wi-Fi Pineapple (by Hak5) is a specialized device used for Wi-Fi man-in-the-middle attacks, rogue APs, and client spoofing. It’s often used to perform Karma attacks (responding to probe requests to fool clients into connecting) and to host rogue access points. Detecting a Pineapple or similar rogue toolkit in the vicinity can warn the user of a sophisticated attack in progress.
	•	Detection Clues: A Pineapple can be detected via multiple signatures:
	•	Default SSIDs: Older Pineapple models by default create an open management AP with a name like “Pineapple_XXXX” or similar. Spot ESP should scan all beacon frames’ SSID strings for known Pineapple default names or patterns reported by the community.
	•	Multiple SSIDs from one device: The Karma attack causes the Pineapple to broadcast many SSIDs (often those it has seen in probe requests). If Spot ESP sees a single BSSID (MAC address) advertising dozens of different network names in a short span, this is highly suspect (normal APs usually advertise 1 or a small number of SSIDs, e.g., for dual-band or guest networks). Detecting an access point beaconing numerous SSIDs or rapidly changing SSID is a strong Pineapple indicator.
	•	MAC OUI/Vendor: Identify the Wi-Fi chipset MAC OUI. Pineapples have used hardware like Atheros or Realtek units. If we know specific OUIs commonly used by Pineapple devices (for example, devices from OpenWrt boards or Hak5), Spot ESP can flag those. However, attackers could spoof MACs, so this is a secondary check.
	•	Client Behavior: Pineapple devices often perform aggressive scanning and client spoofing. Spot ESP can monitor if any device in range is sending probe responses to many different probe requests not directed at it (normal APs respond only to their own SSID probes). If our sniffer sees a device that responds to probes for various SSIDs (i.e., acting like a rogue AP responder), this suggests a Karma attack device like Pineapple.
	•	Alert Mechanism: If a Pineapple is suspected, Spot ESP issues a high-priority alert (as this means someone may be actively trying to intercept Wi-Fi connections). The UI might show “⚠️ Wi-Fi Pineapple device detected!” possibly alongside the suspicious device’s MAC and any SSID clues (e.g., “Broadcasting multiple SSIDs: FreeWifi, CoffeeShop, Airport_WiFi…”). This real-time feedback lets the user take defensive action (like avoid connecting to Wi-Fi or inspect the area). Logging should include all the evidence (MAC, OUIs, SSIDs, channel).
	•	Reference: The approach here is inspired by Wi-Fi IDS techniques. While Spot ESP is passive, by leveraging the Wi-Fi sniffing capabilities we can implement a Pineapple detection mode similar to how Marauder added detection for devices like Pwnagotchi and others in updates . In practice, a combination of SSID analysis and frame pattern observation provides the detection.

3.5 Nearby Flipper Zero Detection
	•	Threat Device: The Flipper Zero is a multi-tool that can emit sub-1GHz signals, NFC, infrared, and with an add-on Wi-Fi dev board, can perform Wi-Fi attacks (running Marauder firmware). It also has Bluetooth capabilities (used to pair with the Flipper mobile app or for certain attacks like BLE spam). While Flipper Zero itself is not solely a Wi-Fi tool, detecting if one is nearby may indicate an attacker with a capable device in proximity.
	•	Detection via Bluetooth: The most practical way to detect a Flipper Zero is through its Bluetooth presence. By default, when Bluetooth is enabled on Flipper (for connecting to the smartphone app), it advertises itself. Many Flipper Zeros have a default BLE device name that includes “Flipper” or a distinctive pattern (sometimes the name is “Flipper” followed by an animal emoji). Spot ESP’s BLE scanner can watch for any device name or manufacturer info matching Flipper’s signature. If known, include the BLE MAC prefix that Flipper uses – a community tool “Wall of Flippers” detects Flippers by scanning for specific Bluetooth MAC prefixes allocated to that device . Spot ESP can incorporate that same list of prefixes. (Note: This method isn’t foolproof, as MACs can be randomized/spoofed , but it’s a starting point.)
	•	Detection via Wi-Fi: If the Flipper Zero user attaches the Wi-Fi dev board and actively runs attacks, those attacks (like deauth or fake APs) will be caught by our other detection mechanisms (deauth detection, rogue AP detection). However, to specifically identify that the source is a Flipper: the Wi-Fi dev board is essentially an ESP32, so its signals look like any other ESP32 running Marauder. There isn’t a unique Wi-Fi fingerprint for Flipper’s board except possibly the MAC OUI (Espressif). Spot ESP might notice if an Espressif OUI (e.g., DC:44:B6 or 24:6F:28, common ESP32 OUIs) is seen performing attacks – but since our own device is an ESP32, that alone isn’t conclusive. Thus, direct Wi-Fi identification of Flipper is not reliable.
	•	Additional Clues: If the user base of Spot ESP suggests typical Flipper usage patterns (for instance, Flipper tends to do short bursts of deauth on multiple channels, or it might create a Wi-Fi network called “Flipper_XYZ”), we can include those patterns. For example, when Flipper runs Marauder, it might broadcast a default SSID like “ESP32 Marauder” or similar for its web UI – scanning for such SSIDs or hostnames could be an option.
	•	Alerting: When a potential Flipper Zero is detected via BLE, show a message such as “🔎 Flipper Zero device in proximity (Bluetooth MAC xx:xx:xx:* )”. This is a lower-severity alert; by itself a Flipper isn’t attacking, but it warns the user to be vigilant. If that same device is also seen engaging in an attack (say deauth frames coincide with the Flipper’s presence), then Spot ESP can elevate the alert (e.g. “Flipper Zero may be attacking network – deauth observed”). Logging should pair the BLE detection event with any concurrent Wi-Fi events.
	•	User Options: Provide a toggle for Flipper detection, since not everyone will need this (it could reduce false alerts in areas with many hobbyists). The implementation is largely a specific case of BLE device fingerprinting, extending the general BLE scan.

3.6 Wi-Fi Network Anomaly Detection
	•	Definition: “Network anomalies” cover any unusual patterns in the local Wi-Fi environment that could indicate malicious activity or network problems. Spot ESP, acting like a mini Wireless Intrusion Detection System (WIDS), will continuously analyze the 802.11 traffic it sees for anything out of the ordinary.
	•	Types of Anomalies to Detect:
	•	Unusually High Traffic or Scans: If the device observes a sudden spike in overall Wi-Fi management frames (probes, auths, etc.) on a channel, it could mean someone is actively scanning or attempting something. For instance, hundreds of probe requests per minute (especially if from many sequential fake MACs) might mean a wardriving tool or a probing attack is active. Spot ESP’s packet monitor functionality (similar to Marauder’s packet monitor graph ) can establish a baseline and detect spikes.
	•	EAPOL Handshake Captures: If using in an environment where the device is associated with an AP, seeing repeated EAPOL (WPA handshake) packets could indicate someone running a handshake capture attack (like a Pwnagotchi or attacker trying to capture hashes for cracking). Spot ESP can sniff for EAPOL messages; if it sees handshakes for multiple clients or repeated retries, it flags it (as normal usage wouldn’t trigger so many handshakes in short time unless new clients join or someone deauths them to force handshakes).
	•	Malformed Frames or Floods: Detect low-level anomalies like invalid frame types or continuous RTS/CTS floods (a DoS method), although these are rarer. The ESP32’s promiscuous callback provides RSSI and length; extremely large numbers of control frames could be noted as unusual.
	•	AP Configuration Oddities: Spot anomalies in beacon frames: e.g., if an AP normally uses WPA2 and suddenly there’s another beacon with same SSID advertising no encryption, or an AP advertising an impossible set of capabilities. These could indicate a misconfigured device or an attacker messing with beacon frames.
	•	Multiple MAC Use (Spoofing): If the same MAC address appears to be acting as multiple device types (for example, one MAC seen sending both client probes and AP beacons), that’s abnormal. This could happen if someone is spoofing MACs clumsily. Our sniffer logic can cross-check roles.
	•	Anomaly Engine: Implement a lightweight rule-based system. Define expected normal behavior (which can be learned after a few minutes of runtime or pre-defined defaults), then trigger on deviations. Ghost ESP firmware’s goal is similar – it “monitors network traffic, detects anomalies, and provides real-time alerts” , which Spot ESP will emulate in a simplified manner. For example, maintain counts of different frame subtypes per interval and if any count is 5× higher than average, flag it. Or if a new AP appears with the same SSID as a known one but different security, mark it (this overlaps with Rogue AP detection below).
	•	Alerting: When a network anomaly is detected, the UI might show a generic warning or a specific message depending on the rule. Some anomalies might be low-level enough that only a log entry is made (to not overwhelm the user with technical details). More user-friendly descriptions can be given, e.g. “Unusual Wi-Fi scanning activity detected on channel 1” or “Potential handshake capture attempt observed (multiple EAPOL packets)”. The alerting should help users decide on next steps (e.g., maybe shut off Wi-Fi or investigate).
	•	User Configuration: Allow advanced users to tweak sensitivity – for instance, how many probe requests per minute triggers an alert – or to enable/disable certain anomaly checks. This customization acknowledges that different environments (crowded office vs. home) have different baselines.

3.7 Rogue Access Point Detection
	•	Definition: A rogue AP could be an unauthorized wireless access point in the area, often set up to trick users (evil twin attack) or simply an AP that should not be there (for example, an employee’s unsanctioned hotspot). Spot ESP will scan for rogue APs with two main approaches: evil-twin detection and open/malicious AP identification.
	•	Evil Twin Detection: If the user provides a list of “trusted networks” (SSIDs and optionally expected BSSIDs or encryption types), Spot ESP can watch for impostors. For instance, if “HomeWiFi” is known to be WPA2-protected and normally on channel 6 with a specific MAC, and we suddenly see another “HomeWiFi” on a different channel or with no encryption, that’s a rogue. Even without a preset list, the firmware can automatically flag same-name networks with differing characteristics: e.g., two APs named “StarbucksWiFi” where one is open and one is WPA2, or their MAC OUIs suggest different manufacturers – likely one is fake.
	•	Unsanctioned APs: Spot ESP should identify APs that are out of place: for example, an unknown SSID that closely resembles a common one (phishing Wi-Fi names like “Free_Public_WiFi” or “Default_WiFi”) especially if open or using weak security. These might be set by attackers to lure connections. Also, APs on unusual channels (like a strong signal on a channel not typically used in your area) could be flagged.
	•	Scanning Implementation: Use continuous beacon frame scanning (which we have from the sniffer) to maintain a list of observed SSIDs and BSSIDs. For each SSID seen, check how many distinct BSSIDs and what security each advertises:
	•	If the same SSID appears with conflicting security (open vs encrypted), mark as suspicious.
	•	If the same SSID appears on multiple channels or BSSIDs far apart in MAC (different OUIs), could be legitimate (like multi-AP setups) or could be evil twin – combine with signal strength or recent deauth events to assess (an attacker might deauth you from legit and you see a strong fake AP after).
	•	If an SSID is exactly the same as the user’s current AP and a new BSSID appears with stronger signal, that’s a red flag (classic evil twin tactic).
	•	Alerting: On detecting a likely rogue AP, the device shows an alert “⚠️ Rogue Access Point detected: SSID ‘XYZ’”. If possible, include why it’s flagged (e.g., “Duplicate network name with different security” or “Unknown AP matching your network’s SSID”). This helps the user trust the alert. Logs should store the MAC, channel, signal strength, and encryption type of both the real and suspected rogue for later analysis.
	•	Note: Some environments (like large offices or public areas) have many APs with same SSID (enterprise networks with multiple APs). To avoid false positives there, Spot ESP might have a “learning mode” where it records legitimate AP clusters (e.g., if it sees 5 BSSIDs all named CorpNet and all using WPA2, it can assume that’s the normal deployment). Then a rogue would be something outside that cluster (say an open CorpNet or one on a wrong channel). This is an advanced feature and could be optional.
	•	Relation to Pineapple: Many rogue APs might be from Pineapple devices. So there is overlap with Pineapple detection. The difference is rogue AP detection focuses on the SSID/security mismatch and unauthorized network presence, whereas Pineapple detection (3.4) looked at device behavior. In practice, if a Pineapple is active you may get both alerts – Spot ESP might say a Pineapple device is detected and also identify specific rogue SSIDs it’s creating.

3.8 Spoofing Attack Detection
	•	Spoofing Types: In wireless context, spoofing can refer to MAC spoofing (an attacker impersonating another device’s MAC address) or ARP/IP spoofing in the network (poisoning ARP tables to intercept traffic). Spot ESP can attempt to detect both to some extent:
	•	MAC Spoofing (Wi-Fi): If an attacker impersonates the MAC of a trusted AP (as in evil twin) or even a client device, the sniffer might catch anomalies. For example, two devices using the same MAC address at overlapping times (which should never happen legitimately) – e.g., if we see one MAC sending a beacon and the same MAC sending a probe as a client. By tracking device state, Spot ESP can identify if a single MAC is seen performing roles of both AP and station or appearing in two places (which is a sign of MAC spoof or a virtualization/test environment anomaly).
	•	ARP Spoofing (Network MITM): If Spot ESP connects to a Wi-Fi network (this could be optional as it’s not purely passive then), it can periodically scan ARP tables or send ARP requests for the gateway. An ARP spoof attack (a type of MITM where an attacker makes your device think it’s the router) will result in the gateway’s IP mapping to an unexpected MAC (attacker’s MAC). Spot ESP could run a small task that checks if the router’s MAC changes or if two different IPs claim to be gateway. Similarly, gratuitous ARP replies on the network can be sniffed for signs of ARP poisoning. This requires being associated with the network to see ARP traffic, which the user may or may not allow Spot ESP to do.
	•	Detection Approach:
	•	For MAC spoofing on Wi-Fi, implement logic in the sniffer to identify impossible behavior. Keep a dictionary of MAC -> last seen activity type. If the same MAC is seen as an AP and also as a client to another AP, raise a flag. Also, monitor if an AP’s MAC changes during an active attack (some advanced attacks quickly switch MACs, but ESP might not catch it if channel hopping slowly).
	•	For ARP spoofing, if Spot ESP is connected to network (even as a silent client), record the legitimate gateway MAC on association. Then listen for ARP announcements: if an ARP packet claims the gateway IP from a different MAC, that’s a likely MITM attempt. Another sign is duplicate IP addresses: if two devices respond to the same IP ARP, indicating IP spoof.
	•	Alerting: A MAC spoofing detection could trigger a message like “⚠️ MAC Spoofing: Device 12:34:56:78:9A:BC is impersonating another device.” This is advanced and might sometimes be a false alarm (MAC randomization features in modern phones could appear as ‘spoofing’ if not handled – e.g., a phone using random MAC for probing vs actual MAC for connecting). Spot ESP should account for known randomization patterns (like Apple devices using private MACs for scans).
For ARP spoof, if implemented, an alert like “⚠️ ARP Spoofing detected on network – potential MITM!” could be shown, advising the user that network traffic might be compromised. Logs should include details (e.g., “IP 192.168.1.1 was claimed by MAC AA:BB:CC:DD:EE:FF instead of router’s MAC GG:HH:II:JJ:KK:LL”).
	•	Preventive Action: While Spot ESP is detection-only (no offensive response), upon detecting spoofing it can optionally send a deauth to itself (disconnect from Wi-Fi) to avoid further MITM, and prompt the user to not use the network. However, since we avoid offense, it might just warn and not transmit any frames.
	•	Note: Spoofing detection, especially ARP, crosses into network-layer monitoring. This is somewhat beyond the pure passive sniff, but it’s included for completeness as part of “network anomalies.” If keeping Spot ESP completely passive, we might skip active ARP checks and focus on MAC-level spoof detection.

4. User Interface Layout and Interaction

A user-friendly menu-style UI on the Cheap Yellow Display is crucial for Spot ESP, so that users can easily navigate and view real-time attack feedback and logs. The interface will be designed for quick glances (for alerts) as well as deeper inspection (via menus). Key elements of the UI:
	•	Main Screen / Dashboard: Upon boot, Spot ESP can show a dashboard that includes real-time status: e.g. Wi-Fi channel currently being scanned, number of networks detected, any alerts active, etc. It might have icons or small text areas for each category (Wi-Fi, BLE) with a green/red status. For example, a Wi-Fi icon that turns red if a Wi-Fi attack is detected, a Bluetooth icon for BLE attacks, etc. The bottom of the screen could show soft-buttons (if using touch) like “Menu” or “Silence Alarm”.
	•	Menu Navigation: The UI will have a menu that the user can invoke (e.g., tapping a menu icon or pressing a side button). The menu might be a list of options:
	•	Live Monitor – returns to the dashboard live view.
	•	View Alerts/Logs – opens a list of recent alerts or a log viewer.
	•	Wi-Fi Scan Details – show all APs/devices seen (like a wardriving list).
	•	Bluetooth Scan Details – list of BLE devices seen (with suspicious ones highlighted).
	•	Settings – configure thresholds, toggles (enable/disable certain detectors, adjust screen brightness, etc.).
	•	Touch Interface: Since the CYD has a resistive touchscreen, design large touch targets (buttons) to accommodate finger or stylus presses. Use simple menus that can be scrolled if many items. For example, on the “View Alerts” screen, you might list alerts with timestamps; touching one could expand details or open a detailed log entry. “Settings” can have toggle switches drawn or simple on/off text that toggles when touched. Marauder’s interface used a similar list menu which could be navigated by touch or physical buttons , and Spot ESP can follow suit, prioritizing ease of use.
	•	Real-Time Feedback Display: For continuous monitoring, dedicate a portion of the screen to show live info. Possibly a scrolling text area or ticker that prints events as they happen (“Deauth frame from MAC X on ch11” or “BLE device ABC detected”). Use color-coding for severity (e.g., red text for attacks, yellow for warnings, white for info). Because printing every packet would be overwhelming, apply filters – e.g., only show noteworthy events (like “Deauth attack detected!” rather than every single deauth counted). This gives the user immediate situational awareness.
	•	Visual Indicators: Leverage the RGB LED on the board in tandem with on-screen indicators. For instance, when everything is normal, LED is green; when a warning (medium severity) is detected, LED turns yellow; on a high severity attack, LED flashes red. The screen can similarly invert colors or flash an icon for critical alerts to catch attention (since a user might not be staring at the device at all times).
	•	Menu to Logs Transition: The UI for logs might allow pausing the live monitor so the user can scroll through past events. Implement paging if logs are large. Possibly allow inserting an SD card and exporting logs if needed (though not required, it’s a plus for usability to analyze data on a PC later).
	•	User Acknowledgment: When an alert is triggered, provide an on-screen option to acknowledge or silence it (especially if the speaker is beeping). For example, a popup “Deauth attack detected [ OK ]” that the user can tap to confirm they’ve seen it, which could then stop further beeps for that incident. Unacknowledged critical alerts might continue to prompt or flash to ensure the user notices.
	•	Layout Considerations: The 240x320 screen allows for a top status bar (with icons for Wi-Fi, BLE, battery if applicable, time), a main content area, and maybe a bottom status or button bar. Use a clear font (TFT_eSPI includes some or use an 8-bit small font for logs). Ensure text is readable in daylight if the device is used outdoors (the CYD’s screen backlight control can be turned up in bright conditions).
	•	Example Interaction Flow: A possible flow – On detecting an attack, the device beeps and the dashboard screen flashes an alert banner. The user taps the banner, which takes them to the Alerts screen with details about that attack and possibly suggestions (like “Deauth attack – consider disconnecting sensitive devices”). The user can then go back to live view or into a Wi-Fi detail view to see which networks/devices are around, etc. This kind of flow makes Spot ESP not just a silent monitor but an interactive tool that guides the user through understanding the threats.
	•	Polish: Include small touches like a logo or name on the main screen (branding as “Spot ESP”), and perhaps an animation or icon (like a shield) when everything is safe. Make sure the UI remains responsive even while monitoring (this may require careful use of tasks or loops so that drawing to screen doesn’t halt scanning for too long).

5. Logging and Alert Mechanisms

Robust logging and clear alerts are essential for a security device. Spot ESP will implement multi-level logging (in-memory, on-screen, and optional persistent storage) and a variety of alert notifications:
	•	Real-Time Alerts: When a detection algorithm triggers an alert, it should immediately update the UI (as described, e.g., banner or message) and optionally use audible/visual cues. For sound, a short beep sequence or tone from the speaker can signal different alert types (maybe one beep for a warning, three rapid beeps for a serious attack). The RGB LED will also reflect the highest current alert level (green = none, yellow = moderate, red = high). These real-time alerts ensure the user is quickly notified of threats.
	•	On-Screen Log/Alert List: Maintain a scrollable list of recent events/alerts on the device. Each entry could include a timestamp and a brief description (e.g., “[12:05:23] Deauth attack detected on AP MyHomeNetwork (MAC 11:22:33:44:55:66)”). The user can open this log to review what has happened. This is stored in RAM while running; limit the list to a certain number (to avoid memory issues), or implement it as a circular buffer. The most recent events are most important to see.
	•	Persistent Logging: For more permanent record, use the SD card (if inserted) to write logs. The firmware can append events to a log file (like spotesp.log or daily timestamped files). Ensure to flush writes to avoid losing data if power is lost. This persistent log allows later analysis or providing evidence of an attack. For space and privacy, consider log rotation or truncating older entries over time.
	•	Data Logged: For each detection, log relevant data points:
	•	Date/time (the RTC of ESP32 can be used or at least uptime seconds if no real-time clock).
	•	Type of alert (Deauth, Rogue AP, etc.).
	•	Details (MAC addresses, channel, SSID, device names, etc., depending on the alert).
	•	Signal info if applicable (RSSI of frames, to estimate distance).
	•	User action if any (like user acknowledged alert).
This creates a comprehensive timeline of events.
	•	Alert Levels/Priorities: It’s useful to classify alerts (info, warning, critical). For example, detecting a new AP that might be rogue could be a warning, whereas detecting an active deauth attack on your network is critical. Use these levels to decide sound/LED intensity and maybe to filter the on-screen display (so minor info events don’t flood the UI unless user wants verbose output).
	•	Silent Mode and Alert Customization: Provide options in settings to mute the speaker (maybe the user only wants visual alerts) or to turn off LED if needed (for stealth monitoring scenarios). Also allow enabling/disabling certain logs – for example, one might turn off logging of every probe request seen (verbose) and only log actual attacks.
	•	Networking Logging (Advanced): If Spot ESP connects to a network (for ARP detection or maybe uploading logs), ensure not to expose the device itself. Ideally, Spot ESP remains a passive monitor. If future expansion considered: it could send alerts to a phone app via BLE or Wi-Fi (like push notifications), but this is optional and not required by the scope. For now, local logging and alerts suffice.
	•	Log Viewing and Management: The UI’s log viewer can allow the user to scroll through entries and maybe clear them. A “Clear Logs” option could wipe the in-memory list (and optionally the file). Confirm with the user before deleting any persistent logs.
	•	Incorporating Defensive Info from Others: We can take inspiration from how Marauder and Ghost handle logging. Marauder allowed logging to SD of captured data (packets) , which Spot ESP could do for advanced users (e.g., write a PCAP of sniffed deauth frames for later analysis in Wireshark). Ghost ESP emphasized real-time alerts , so we ensure our alerts are indeed real-time and visible. By combining both, Spot ESP logs data for the user to investigate and simultaneously keeps them informed live.
	•	Example Alert Flow: Suppose a rogue AP is detected. Spot ESP: (1) adds an entry to log “Rogue AP SSID X detected, MAC …, channel …” with time; (2) turns LED yellow and beeps once; (3) shows an alert icon on screen. The user opens the alert detail which might say “A rogue access point with your network name was found on a different channel. This could be an Evil Twin attack.” This explanatory style helps even non-experts understand the implication of the alert, which is part of a user-friendly design.
	•	Fail-safe Logging: In case of heavy attack (say thousands of events), ensure the logging system doesn’t crash the device. Implement rate-limiting for identical alerts (e.g., log “deauth attack ongoing…” once and then maybe update a counter rather than logging every single packet). The idea is to capture the essence of the attack in the log without the log itself becoming unwieldy or using too much CPU to write.

6. Performance Optimization Strategies

Continuous monitoring of Wi-Fi and BLE can be resource-intensive on the ESP32. We need to optimize for smooth operation and to maintain reasonable power usage. Key strategies include:
	•	Efficient Packet Processing: Use interrupt/callback based sniffing rather than polling. The Wi-Fi promiscuous callback gives packet data; in that callback (which runs on high priority), do minimal work – e.g., just filter for what we care about (like deauth frames) and increment counters or set flags. Avoid doing heavy analysis directly in the ISR context. Instead, set a flag or copy needed data to a buffer and handle it in the main loop or a lower-priority task. This prevents dropping packets and keeps the system responsive.
	•	Channel Scanning Strategy: Instead of naive round-robin channel hopping at constant speed, optimize the channel dwell time based on context. For example, if the device is connected to Wi-Fi on channel 6 (for ARP monitoring), spend more time on channel 6 (since attacks affecting you would likely occur there). If a particular channel has many APs (from a quick survey), you might dwell a bit longer to catch more there. Conversely, quiet channels can be scanned quickly. This adaptive channel hopping improves the chances of catching attacks without always having to scan all channels evenly.
	•	Bluetooth Scanning Tuning: BLE scanning parameters can greatly affect CPU and power. A smaller scan window (the fraction of time radio listens) saves power but might miss some adverts. We can choose a moderate duty cycle (e.g., scan window 50% of interval). Also, use the lowest BLE scan duplicate filter if available (to avoid processing the same advertisement repeatedly within a short time). If the environment is very busy with BLE devices, consider scanning in short bursts and then pausing, to give Wi-Fi some uninterrupted time (because Bluetooth scanning could otherwise steal radio time from Wi-Fi). Testing will help find a balance where neither Wi-Fi nor BLE detection suffers greatly.
	•	Task Prioritization: Use FreeRTOS tasks for different subsystems: one for Wi-Fi sniffing analysis, one for BLE scanning/analysis, one for UI updates. Assign appropriate priorities (Wi-Fi sniff processing might be high priority, UI medium, etc.). This way, a burst of packets won’t completely freeze the UI updates – the UI task can still run to show an alert, even if some packets are queued for analysis. However, avoid too high frequency UI refresh (limit screen draws per second) to not hog the CPU.
	•	Memory Management: Allocate buffers for sniffed data carefully. The ESP32 has limited RAM, so for example if capturing raw packets, do not buffer too many. Perhaps store only a sliding window of recent events. Use static allocations where possible to avoid fragmentation (especially if using Arduino environment). If using dynamic memory (malloc/free), be mindful of fragmentation over long uptime – better to use fixed-size buffers or pools.
	•	Use of ESP32 Hardware Features: The ESP32 has hardware acceleration for certain tasks. For instance, the Wi-Fi packet filtering in promiscuous mode can be set to filter by packet type (to only receive management frames, etc.), which reduces overhead of handling irrelevant traffic. Leverage that: call esp_wifi_set_promiscuous_filter() to get only the types we need (management and maybe control frames, since data frames aren’t needed for our detection) – this reduces load . On the BLE side, hardware filters for specific advertisement content could be used (e.g., scan for devices with certain service UUIDs only when looking for skimmers) to cut down processing of every BLE advert.
	•	Power Saving Measures: If the device will be battery-powered, implement power optimization:
	•	Dim or turn off the TFT backlight after a period of inactivity (while still monitoring in background). Perhaps enter a “screensaver” mode where just the LED might indicate status, and the display wakes if touch is detected or an alert occurs.
	•	Use light sleep in between channel hops or BLE scan intervals if possible. For example, if scanning in bursts, the ESP32 could sleep for a short time (tens of milliseconds) when idle. But careful: we can’t sleep too long or we’ll miss packets. Light sleep may also disrupt Wi-Fi radio, so this needs testing.
	•	Lower CPU frequency when full performance isn’t needed – e.g., run at 80MHz instead of 240MHz when environment is quiet, and scale up when an attack is detected or heavy processing is needed.
	•	Efficient UI Drawing: Drawing to the TFT can be slow (it’s SPI-based). Optimize UI updates by only updating parts of the screen that change (e.g., use double buffering or TFT_eSPI’s sprite class to prepare screens off-screen and then push). Avoid full-screen redraws every loop. This ensures the CPU can spend time on scanning. For instance, update the packet counters on screen maybe 2 times a second, not every packet. This way, monitoring isn’t impacted by UI rendering overhead.
	•	Testing and Profiling: Use diagnostic tools to measure how many packets are processed, how much CPU time tasks take, etc. ESP-IDF has performance counters; if using Arduino, simple counters and logs can help. For example, ensure that the system can handle a scenario like a deauth flood (hundreds of packets/second) without dropping all of them. If performance is an issue, consider simplifying some detection algorithms or making some checks less frequent.
	•	Benchmark in Stages: Develop and test Wi-Fi scanning alone first, optimize it, then add BLE scanning and optimize, then UI, etc. This incremental approach helps pinpoint bottlenecks. It might turn out that alternating between Wi-Fi and BLE scanning (instead of truly simultaneous) yields better results – e.g., scan BLE for X ms, then switch to Wi-Fi sniffer for Y ms, repeat. If so, we can implement that as a scheduled loop. The end goal is a responsive, efficient monitor that can run for extended periods.

7. Potential Challenges and Solutions

Implementing Spot ESP is ambitious and may face several challenges. Below we outline these potential issues and how to address them:
	•	Concurrent Wi-Fi and BLE Operations: Running Wi-Fi in promiscuous mode while scanning BLE might cause radio coexistence problems. The ESP32’s radio is shared between Wi-Fi and Bluetooth, so heavy use of both can degrade performance or miss events. Solution: Fine-tune scan intervals (as discussed) and consider time-slicing. Espressif’s coexistence mechanism should handle fair time sharing, but if important events are being missed, implement an explicit scheduler (e.g., pause BLE scanning during critical Wi-Fi sniff phases like channel dwell when expecting something, and vice versa). Also test on ESP32 dual-core: dedicate one core (e.g., core 0) to networking tasks and the other (core 1) to UI to better handle parallelism.
	•	False Positives vs. False Negatives: Tuning detection algorithms is tricky – too sensitive and users get alert fatigue from false alarms; too lenient and real attacks might slip by. Solution: Provide sane defaults (maybe informed by Ghost ESP’s anomaly detection thresholds) and allow customization. Beta testing in different environments can help adjust the defaults. Implement a way to suppress or classify minor alerts (for example, maybe the user can mark a detected “rogue” AP as actually legitimate, and the system remembers to not flag it next time). Use logging to refine: if logs show certain events always flagged but later determined harmless, adjust the logic.
	•	Limited Packet Visibility: The ESP32 in promisc mode can capture a lot, but it cannot decrypt Wi-Fi traffic (so it can’t see inside data frames on protected networks) and can miss packets when channel hopping. Attacks might be missed if they are short and happen on a channel when we’re not listening. Solution: Channel hopping frequency is a trade-off. We might allow the user to specify channels of interest (if they only care about specific Wi-Fi channels, focus on those). For missing context due to encryption, focus on what can be observed in plaintext (deauth, beacons, etc. are all visible because they’re management frames). For network anomalies like ARP spoof, that required being on the same network – if Spot ESP isn’t connected, it won’t see those. Thus, make it clear to user: some features (like ARP spoof detection) need Spot ESP to join the network. Possibly provide a mode where user can input their Wi-Fi password so the device can join and monitor from inside; if not, it will skip those checks.
	•	Hardware Limitations: The CYD hardware is capable, but things like the resistive touch can be finicky (needs calibration and can be less responsive than capacitive). The screen is also small for large logs. Solution: Ensure calibration happens and maybe allow using the two hardware buttons (BOOT/RST or others if available) for navigation as an alternative. For viewing large logs, perhaps implement page-by-page viewing or allow exporting the log to SD for reading on a PC if needed. Also, the speaker might be just a buzzer with limited sound – use simple tones that are within its capability. And note memory limits: ESP32 has ~520KB RAM, which can be quickly used by buffers for display, BLE, Wi-Fi. Stay mindful of that by not using huge data structures (e.g., do not store entire packet payloads unneeded; just store headers or counts).
	•	Integrating External Code: We plan to incorporate ideas from Marauder, Ghost, Bruce. Copying code directly might lead to integration issues or bloat if not careful. Solution: Instead of lifting large code sections, identify the specific techniques and re-implement them in a lightweight way. For example, Marauder’s deauth detection is essentially counting deauth frames – we can write our own using ESP-IDF API rather than importing the whole Marauder project. This way, we avoid bringing unnecessary offensive code. Use those projects mainly as references. We should credit any code used and ensure license compliance if code is reused.
	•	Testing in Real Scenarios: To ensure Spot ESP reliably detects attacks, we’ll need to simulate or perform those attacks in a controlled manner. This might be challenging for things like Pineapple detection if we don’t have a Pineapple device. Solution: Use alternatives: e.g., use an extra ESP32 running Marauder in offensive mode to simulate deauth and fake APs (since Marauder can do beacon spam etc.), use a smartphone app or another Flipper to simulate BLE spam or Flipper presence. For skimmers, perhaps use an HC-05 module to test detection. Essentially, gather a toolkit to generate test signals. This helps validate our detection logic. Also consider using a packet capture tool (like an Ubertooth for BLE or Wi-Fi sniffer on a laptop) in parallel to verify that Spot ESP is catching what it should.
	•	User Experience Balancing: There’s a challenge to present potentially complex network events to users in a simple way. We risk confusing users with technical jargon or, conversely, oversimplifying so much that they don’t grasp the seriousness. Solution: Iterate on UI messages and possibly include a small help section or tooltips in the UI (for example, next to each alert type in settings, have a “?” that explains what a deauth attack is in simple terms). Since Spot ESP is defensive, it might be used by people who are not highly technical but want security awareness. Therefore, clarity in UI and documentation is key. We will create a user manual explaining each alert type briefly and what actions a user might consider (though Spot ESP itself won’t take offensive action, the user might decide to turn off devices, move away, etc.).
	•	Firmware Size and Updates: With many features, the firmware might become large. The ESP32 has ample flash (typically 4MB), but if using Arduino, keep an eye on partition sizes especially if we use OTA in future. We should also plan for easy updating of Spot ESP firmware (maybe via SD card or serial). Given this is a development plan, just note that as the project evolves, having a smooth update path (like Marauder’s web or SD update features ) would be beneficial.
	•	Legal and Ethical Considerations: Spot ESP is purely passive, which is good (should be legal in most places to just receive radio signals). But if we ever consider adding any interactive feature (even just sending a deauth to itself as a mitigation, or beacon as bait), we must ensure we don’t cross into offensive territory without user knowledge. Solution: Keep the project’s scope clearly on detection. Provide warnings in documentation that some detection (like connecting to a network to check ARP) should only be done on networks you own or have permission for. Basically, maintain ethical use guidelines, similar to how Marauder warns users .

By anticipating these challenges and planning solutions, the development of Spot ESP can proceed more smoothly and result in a reliable defensive tool.

⸻

With this plan, Spot ESP will leverage the ESP32-CYD hardware to provide a comprehensive defensive monitoring tool. We have outlined the needed libraries and setup, detailed how to detect various attacks, designed an intuitive UI, and addressed logging, performance, and potential pitfalls. Following this guide, implementation can proceed in stages (hardware bring-up, basic scanning, each detection feature, UI integration, etc.), resulting in a firmware that enhances security awareness for users in real-time. By focusing on detection-only mechanisms and learning from existing projects like Marauder, Ghost ESP, and Bruce (which each offer similar Wi-Fi/Bluetooth scanning capabilities  ), Spot ESP aims to be a fresh, optimized solution tailored for the Cheap Yellow Display platform, turning it into a portable wireless threat detector.
